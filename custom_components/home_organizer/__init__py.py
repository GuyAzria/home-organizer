# -*- coding: utf-8 -*-
"""custom_components/home_organizer/__init__.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oJcpDC6bgK3iUHNBpTfPRby2XkLrJ05s
"""

# Home Organizer Ultimate - ver 2.0.0
# Written by Guy Azaria with AI help

import logging
import sqlite3
import os
import shutil
import base64
import time
import io
from datetime import datetime, timedelta
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant, ServiceCall
from homeassistant.components import panel_custom
import google.generativeai as genai
import PIL.Image
from .const import DOMAIN, CONF_API_KEY, CONF_DEBUG, DB_FILE, IMG_DIR, VERSION

_LOGGER = logging.getLogger(__name__)
MAX_LEVELS = 10

async def async_setup(hass: HomeAssistant, config: dict) -> bool:
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    # Debug Mode
    if entry.options.get(CONF_DEBUG): _LOGGER.setLevel(logging.DEBUG)

    # AI Setup
    api_key = entry.options.get(CONF_API_KEY, entry.data.get(CONF_API_KEY))
    if api_key:
        try: genai.configure(api_key=api_key)
        except: pass

    # Frontend Install
    await async_setup_frontend(hass)

    # Register Panel
    await panel_custom.async_register_panel(
        hass,
        webcomponent_name="home-organizer-panel",
        frontend_url_path="home-organizer",
        module_url=f"/local/home_organizer_libs/organizer-panel.js?v={int(time.time())}",
        sidebar_title="ארגונית",
        sidebar_icon="mdi:package-variant-closed",
        require_admin=False
    )

    # DB Init
    await hass.async_add_executor_job(init_db, hass)

    # Memory State
    hass.data.setdefault(DOMAIN, {})
    hass.data[DOMAIN] = {
        "current_path": [],
        "search_query": "",
        "date_filter": "All",
        "shopping_mode": False,
        "clipboard": None,
        "ai_suggestion": ""
    }

    await register_services(hass)
    await hass.async_add_executor_job(update_view, hass)

    entry.async_on_unload(entry.add_update_listener(update_listener))
    return True

async def update_listener(hass: HomeAssistant, entry: ConfigEntry):
    await hass.config_entries.async_reload(entry.entry_id)

async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    hass.components.frontend.async_remove_panel("home-organizer")
    return True

async def async_setup_frontend(hass: HomeAssistant):
    src = os.path.join(os.path.dirname(__file__), "frontend", "organizer-panel.js")
    dest_dir = hass.config.path("www", "home_organizer_libs")
    dest = os.path.join(dest_dir, "organizer-panel.js")
    if not os.path.exists(dest_dir): await hass.async_add_executor_job(os.makedirs, dest_dir)
    if os.path.exists(src): await hass.async_add_executor_job(shutil.copyfile, src, dest)

def get_db_connection(hass):
    return sqlite3.connect(hass.config.path(DB_FILE))

def init_db(hass):
    if not os.path.exists(hass.config.path("www", IMG_DIR)): os.makedirs(hass.config.path("www", IMG_DIR))
    conn = get_db_connection(hass)
    c = conn.cursor()
    cols = ", ".join([f"level_{i} TEXT" for i in range(1, MAX_LEVELS + 1)])
    c.execute(f'''CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, type TEXT DEFAULT 'item',
        {cols}, item_date TEXT, quantity INTEGER DEFAULT 1, image_path TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    c.execute("PRAGMA table_info(items)")
    existing = [col[1] for col in c.fetchall()]
    if 'image_path' not in existing: c.execute("ALTER TABLE items ADD COLUMN image_path TEXT")
    conn.commit(); conn.close()

def update_view(hass):
    state = hass.data[DOMAIN]
    path_parts = state["current_path"]
    query = state["search_query"]
    date_filter = state["date_filter"]
    is_shopping = state["shopping_mode"]

    conn = get_db_connection(hass); c = conn.cursor()
    folders = []; items = []; shopping_list = []

    try:
        # 1. Shopping Mode (All items with qty=0)
        if is_shopping:
            c.execute("SELECT * FROM items WHERE quantity = 0 AND type='item'")
            for r in c.fetchall():
                fp = []; [fp.append(r[f"level_{i}"]) for i in range(1, MAX_LEVELS+1) if r[f"level_{i}"]]
                img = f"/local/{IMG_DIR}/{r['image_path']}?v={int(time.time())}" if r['image_path'] else None
                shopping_list.append({"name": r['name'], "qty": 0, "date": r['item_date'], "img": img, "location": " > ".join(fp)})

        # 2. Search Mode
        elif query or date_filter != "All":
            sql = "SELECT * FROM items WHERE 1=1"; params = []
            for i, p in enumerate(path_parts): sql += f" AND level_{i+1} = ?"; params.append(p)

            if query: sql += " AND name LIKE ?"; params.append(f"%{query}%")
            if date_filter == "Week": sql += " AND item_date >= ?"; params.append((datetime.now()-timedelta(days=7)).strftime("%Y-%m-%d"))
            elif date_filter == "Month": sql += " AND item_date LIKE ?"; params.append(datetime.now().strftime("%Y-%m") + "%")
            elif date_filter == "Year": sql += " AND item_date LIKE ?"; params.append(datetime.now().strftime("%Y") + "%")

            c.execute(sql, tuple(params))
            for r in c.fetchall():
                fp = []; [fp.append(r[f"level_{i}"]) for i in range(1, MAX_LEVELS+1) if r[f"level_{i}"]]
                if r['type'] == 'item':
                    img = f"/local/{IMG_DIR}/{r['image_path']}?v={int(time.time())}" if r['image_path'] else None
                    items.append({"name": r['name'], "type": r['type'], "qty": r['quantity'], "date": r['item_date'], "img": img, "location": " > ".join(fp)})

        # 3. Browse Mode
        else:
            depth = len(path_parts)
            sql_where = ""; params = []
            for i, p in enumerate(path_parts): sql_where += f" AND level_{i+1} = ?"; params.append(p)

            if depth < MAX_LEVELS:
                col = f"level_{depth+1}"
                c.execute(f"SELECT DISTINCT {col} FROM items WHERE {col} IS NOT NULL AND {col} != '' {sql_where} ORDER BY {col} ASC", tuple(params))
                for r in c.fetchall(): folders.append({"name": r[0]})

            sql = f"SELECT * FROM items WHERE 1=1 {sql_where}"
            if depth < MAX_LEVELS: sql += f" AND (level_{depth+1} IS NULL OR level_{depth+1} = '')"
            # Sort: Stock first, then missing
            sql += " ORDER BY CASE WHEN quantity > 0 THEN 0 ELSE 1 END, name ASC"

            c.execute(sql, tuple(params))
            for r in c.fetchall():
                if r['type'] == 'item':
                    img = f"/local/{IMG_DIR}/{r['image_path']}?v={int(time.time())}" if r['image_path'] else None
                    items.append({"name": r['name'], "type": r['type'], "qty": r['quantity'], "date": r['item_date'], "img": img, "location": ""})
    finally: conn.close()

    display = "Shopping List" if is_shopping else ("Search Results" if (query or date_filter != "All") else (" > ".join(path_parts) if path_parts else "Main"))

    hass.states.async_set("sensor.organizer_view", "Active", {
        "path_display": display, "folders": folders, "items": items, "shopping_list": shopping_list,
        "clipboard": state["clipboard"], "ai_suggestion": state.get("ai_suggestion", ""), "app_version": VERSION
    })

async def register_services(hass):

    async def handle_set_context(call):
        d = call.data
        if "path" in d: hass.data[DOMAIN]["current_path"] = d["path"]
        if "search_query" in d: hass.data[DOMAIN]["search_query"] = d["search_query"]
        if "date_filter" in d: hass.data[DOMAIN]["date_filter"] = d["date_filter"]
        if "shopping_mode" in d: hass.data[DOMAIN]["shopping_mode"] = d["shopping_mode"]
        hass.data[DOMAIN]["ai_suggestion"] = ""
        await hass.async_add_executor_job(update_view, hass)

    async def handle_add(call):
        name = call.data.get("item_name"); itype = call.data.get("item_type", "item")
        date = call.data.get("item_date"); img_b64 = call.data.get("image_data")
        fname = ""
        if img_b64:
            try:
                if "," in img_b64: img_b64 = img_b64.split(",")[1]
                fname = f"img_{int(time.time())}.jpg"
                await hass.async_add_executor_job(lambda: open(hass.config.path("www", IMG_DIR, fname), "wb").write(base64.b64decode(img_b64)))
            except: pass

        parts = hass.data[DOMAIN]["current_path"]
        cols = ["name", "type", "item_date", "image_path"]; vals = [name, itype, date, fname]; qs = ["?", "?", "?", "?"]
        for i, p in enumerate(parts): cols.append(f"level_{i+1}"); vals.append(p); qs.append("?")

        def db_ins():
            conn = get_db_connection(hass); c = conn.cursor()
            c.execute(f"INSERT INTO items ({','.join(cols)}) VALUES ({','.join(qs)})", tuple(vals))
            conn.commit(); conn.close()
        await hass.async_add_executor_job(db_ins)
        hass.data[DOMAIN]["ai_suggestion"] = ""
        await hass.async_add_executor_job(update_view, hass)

    async def handle_update_image(call):
        name = call.data.get("item_name"); img_b64 = call.data.get("image_data")
        if "," in img_b64: img_b64 = img_b64.split(",")[1]
        fname = f"{name}_{int(time.time())}.jpg"
        pp = hass.data[DOMAIN]["current_path"]; sql_p = ""; prm = []
        for i, p in enumerate(pp): sql_p += f" AND level_{i+1} = ?"; prm.append(p)
        def save():
            open(hass.config.path("www", IMG_DIR, fname), "wb").write(base64.b64decode(img_b64))
            conn = get_db_connection(hass); c = conn.cursor()
            c.execute(f"UPDATE items SET image_path = ? WHERE name = ? {sql_p}", (fname, name, *prm)); conn.commit(); conn.close()
        await hass.async_add_executor_job(save); await hass.async_add_executor_job(update_view, hass)

    async def handle_update_item_details(call):
        orig, nn, nd = call.data.get("original_name"), call.data.get("new_name"), call.data.get("new_date")
        pp = hass.data[DOMAIN]["current_path"]; sql_p = ""; prm = []
        for i, p in enumerate(pp): sql_p += f" AND level_{i+1} = ?"; prm.append(p)
        def db_u(): conn = get_db_connection(hass); conn.cursor().execute(f"UPDATE items SET name = ?, item_date = ? WHERE name = ? {sql_p}", (nn, nd, orig, *prm)); conn.commit(); conn.close()
        await hass.async_add_executor_job(db_u); await hass.async_add_executor_job(update_view, hass)

    # --- עדכון כמות מהיר (למצב רגיל) ---
    async def handle_update_qty(call):
        name = call.data.get("item_name"); change = int(call.data.get("change"))
        today = datetime.now().strftime("%Y-%m-%d")
        pp = hass.data[DOMAIN]["current_path"]; sql_p = ""; prm = []
        for i, p in enumerate(pp): sql_p += f" AND level_{i+1} = ?"; prm.append(p)

        def db_q():
            conn = get_db_connection(hass); c = conn.cursor()
            # מעדכן כמות + תאריך אוטומטי להיום
            c.execute(f"UPDATE items SET quantity = MAX(0, quantity + ?), item_date = ? WHERE name = ? {sql_p}", (change, today, name, *prm))
            conn.commit(); conn.close()
        await hass.async_add_executor_job(db_q); await hass.async_add_executor_job(update_view, hass)

    # --- עדכון מלאי מסל הקניות (למצב קניות) ---
    async def handle_update_stock(call):
        name = call.data.get("item_name"); qty = int(call.data.get("quantity"))
        today = datetime.now().strftime("%Y-%m-%d")
        # בחיפוש גלובלי/סל קניות אנחנו לא יודעים נתיב, מעדכנים לפי שם בלבד (רצוי ID בעתיד)
        def db_upd():
            conn = get_db_connection(hass); c = conn.cursor()
            c.execute(f"UPDATE items SET quantity = ?, item_date = ? WHERE name = ?", (qty, today, name))
            conn.commit(); conn.close()
        await hass.async_add_executor_job(db_upd)
        await hass.async_add_executor_job(update_view, hass)

    async def handle_delete(call):
        name = call.data.get("item_name"); pp = hass.data[DOMAIN]["current_path"]; sql_p = ""; prm = []
        for i, p in enumerate(pp): sql_p += f" AND level_{i+1} = ?"; prm.append(p)
        def db_del(): conn = get_db_connection(hass); conn.cursor().execute(f"DELETE FROM items WHERE name = ? {sql_p}", (name, *prm)); conn.commit(); conn.close()
        await hass.async_add_executor_job(db_del); await hass.async_add_executor_job(update_view, hass)

    async def handle_paste(call):
        target_path = call.data.get("target_path")
        item_name = hass.data[DOMAIN]["clipboard"]
        if not item_name: return
        def db_mv():
            conn = get_db_connection(hass); c = conn.cursor()
            upd = [f"level_{i} = ?" for i in range(1, MAX_LEVELS+1)]
            vals = [target_path[i-1] if i <= len(target_path) else None for i in range(1, MAX_LEVELS+1)]
            c.execute(f"UPDATE items SET {','.join(upd)} WHERE name = ?", (*vals, item_name))
            conn.commit(); conn.close()
        await hass.async_add_executor_job(db_mv)
        hass.data[DOMAIN]["clipboard"] = None
        await hass.async_add_executor_job(update_view, hass)

    async def handle_clipboard(call):
        action = call.data.get("action"); item = call.data.get("item_name")
        hass.data[DOMAIN]["clipboard"] = item if action == "cut" else None
        await hass.async_add_executor_job(update_view, hass)

    async def handle_ai_action(call):
        mode = call.data.get("mode"); img_b64 = call.data.get("image_data")
        if not img_b64: return
        if "," in img_b64: img_b64 = img_b64.split(",")[1]
        try:
            model = genai.GenerativeModel('gemini-1.5-flash')
            image = PIL.Image.open(io.BytesIO(base64.b64decode(img_b64)))
            if mode == 'identify':
                prompt = "Identify this household item. Return ONLY the name in English or Hebrew. 2-3 words max."
                resp = await model.generate_content_async([prompt, image])
                hass.data[DOMAIN]["ai_suggestion"] = resp.text.strip()
                await hass.async_add_executor_job(update_view, hass)
            elif mode == 'search':
                prompt = "Identify this item. Return only 1 keyword for searching."
                resp = await model.generate_content_async([prompt, image])
                hass.data[DOMAIN]["search_query"] = resp.text.strip()
                hass.data[DOMAIN]["shopping_mode"] = False
                await hass.async_add_executor_job(update_view, hass)
        except Exception as e: _LOGGER.error(f"AI Error: {e}")

    for n, h in [
        ("set_view_context", handle_set_context), ("add_item", handle_add), ("update_image", handle_update_image),
        ("update_stock", handle_update_stock), ("update_qty", handle_update_qty), ("delete_item", handle_delete),
        ("clipboard_action", handle_clipboard), ("paste_item", handle_paste), ("ai_action", handle_ai_action),
        ("update_item_details", handle_update_item_details)
    ]:
        hass.services.async_register(DOMAIN, n, h)

    await hass.async_add_executor_job(update_view, hass)
    return True